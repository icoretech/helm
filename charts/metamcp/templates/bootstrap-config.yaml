{{- if .Values.bootstrap.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "metamcp.fullname" . }}-bootstrap
  labels:
    {{- include "metamcp.labels" . | nindent 4 }}
data:
  bootstrap.json: |
    {{- /* Render a single JSON payload the job can print/apply later */ -}}
    {{- $payload := dict "servers" (.Values.bootstrap.servers | default (list)) "namespace" (.Values.bootstrap.namespace | default (dict)) "endpoint" (.Values.bootstrap.endpoint | default (dict)) -}}
{{ toJson $payload | nindent 4 }}
  config.json: |
    {{- /* Unified provisioning config for Python bootstrap: supports both legacy bootstrap.* and new provision.* */ -}}
    {{- $uni := dict "bootstrap" (dict "servers" (.Values.bootstrap.servers | default (list)) "namespace" (.Values.bootstrap.namespace | default (dict)) "endpoint" (.Values.bootstrap.endpoint | default (dict))) "provision" ((.Values.provision | default (dict))) -}}
{{ toJson $uni | nindent 4 }}
  bootstrap.py: |
    import os, json, time
    import requests

    def log(msg):
        print(f"[bootstrap] {msg}", flush=True)

    MODE = os.environ.get('MODE', 'apply')
    NS = os.environ.get('NAMESPACE', 'default')
    SVC = os.environ['SVC']
    FRONTEND_PORT = os.environ.get('FRONTEND_PORT', '12008')
    FRONTEND = f"http://{SVC}:{FRONTEND_PORT}"
    BACKEND = f"http://{SVC}:12009"
    ADMIN_USER = os.environ.get('ADMIN_USER', 'admin')
    ADMIN_PASS = os.environ.get('ADMIN_PASS', 'admin')

    # Unified config
    ucfg = json.load(open('/cfg/config.json','r'))
    boot = ucfg.get('bootstrap', {})
    prov = ucfg.get('provision', {})

    # Health
    for _ in range(90):
        try:
            if requests.get(f"{FRONTEND}/health", timeout=3).status_code == 200:
                break
        except Exception:
            pass
        time.sleep(2)

    log(f"MODE={MODE}")
    log(f"FRONTEND={FRONTEND} BACKEND={BACKEND}")
    log("Config:")
    print(json.dumps(ucfg))
    if MODE == 'print':
        log('Print-only mode. No API calls performed.')
        raise SystemExit(0)

    sess = requests.Session()
    sess.headers.update({'Content-Type':'application/json','Accept':'application/json'})

    # Ensure admin exists then sign in
    try:
        r = sess.post(f"{BACKEND}/api/auth/sign-up/email", json={'email': ADMIN_USER, 'password': ADMIN_PASS, 'name': 'Admin'}, timeout=8)
        if r.status_code not in (200,201,409,422):
            log(f"WARN signup: {r.status_code} {r.text[:160]}")
    except Exception as e:
        log(f"WARN signup exception: {e}")
    r = sess.post(f"{BACKEND}/api/auth/sign-in/email", json={'email': ADMIN_USER, 'password': ADMIN_PASS}, timeout=8)
    if r.status_code != 200:
        log(f"ERROR signin: {r.status_code} {r.text[:160]}")

    # Helper calls
    def trpc_post(path, body):
        return sess.post(f"{BACKEND}{path}", json=body, timeout=12)
    def trpc_get(path):
        return sess.get(f"{BACKEND}{path}", timeout=12)

    # Helper to upsert one server
    def upsert_server(srv, srv_map):
        name = srv.get('name');
        if not name:
            return
        if name in srv_map:
            log(f"server exists: {name}"); return
        stype = (srv.get('type','SSE') or 'SSE').upper()
        if stype in ('SSE','STREAMABLE'):
            stype = 'SSE' if stype=='SSE' else 'STREAMABLE_HTTP'
        body = {'name': name, 'type': stype}
        if stype in ('SSE','STREAMABLE_HTTP'):
            if srv.get('url'): body['url'] = srv['url']
            if srv.get('bearerToken'): body['bearerToken'] = srv['bearerToken']
            if srv.get('headers'): body['headers'] = srv['headers']
        if stype == 'STDIO':
            if srv.get('command'): body['command'] = srv['command']
            if srv.get('args'): body['args'] = srv['args']
            if srv.get('env'): body['env'] = srv['env']
        r = trpc_post('/trpc/frontend/frontend.mcpServers.create', body)
        if r.ok:
            try:
                uuid = r.json()['result']['data']['data']['uuid']
                srv_map[name] = uuid
                log(f"created server: {name}")
            except Exception:
                log(f"WARN: could not parse create response for {name}")
        else:
            log(f"WARN: server create {name} -> {r.status_code}: {r.text[:160]}")

    # Build existing servers map
    srv_map = {}
    try:
        lr = trpc_get('/trpc/frontend/frontend.mcpServers.list?input=%7B%7D')
        if lr.ok:
            for s in lr.json().get('result',{}).get('data',{}).get('data',[]):
                srv_map[s['name']] = s['uuid']
    except Exception:
        pass

    # Legacy bootstrap single payload
    b_servers = boot.get('servers', [])
    b_namespace = boot.get('namespace', {})
    b_endpoint = boot.get('endpoint', {})

    # New provision lists
    p_servers = prov.get('servers', []) if prov else []
    p_namespaces = prov.get('namespaces', []) if prov else []
    p_endpoints = prov.get('endpoints', []) if prov else []

    # Upsert servers (both legacy + new)
    for s in b_servers: upsert_server(s, srv_map)
    for s in p_servers: upsert_server(s, srv_map)

    # Namespaces
    def ensure_namespace(name):
        ns_uuid = None
        lr = trpc_get('/trpc/frontend/frontend.namespaces.list?input=%7B%7D')
        if lr.ok:
            for ns in lr.json().get('result',{}).get('data',{}).get('data',[]):
                if ns.get('name') == name:
                    ns_uuid = ns.get('uuid'); break
        if not ns_uuid:
            r = trpc_post('/trpc/frontend/frontend.namespaces.create', {'name': name})
            if r.ok:
                try:
                    ns_uuid = r.json()['result']['data']['data']['uuid']
                    log(f"created namespace: {name}")
                except Exception:
                    log('WARN: cannot parse namespace uuid')
        return ns_uuid

    # Apply legacy namespace
    ns_uuid = None
    ns_name = b_namespace.get('name') or b_endpoint.get('name')
    if ns_name:
        ns_uuid = ensure_namespace(ns_name)
        ns_servers = b_namespace.get('servers') or []
        if ns_uuid and ns_servers:
            trpc_post('/trpc/frontend/frontend.namespaces.update', {'uuid': ns_uuid, 'name': ns_name, 'servers': ns_servers})

    # Apply provisioned namespaces
    for ns in p_namespaces:
        name = ns.get('name'); 
        if not name: continue
        nid = ensure_namespace(name)
        ns_servers = ns.get('servers') or []
        if nid and ns_servers:
            trpc_post('/trpc/frontend/frontend.namespaces.update', {'uuid': nid, 'name': name, 'servers': ns_servers})

    # Endpoints
    def create_endpoint(ep_name, ns_name_or_uuid, transport='SSE', extra=None):
        lr = trpc_get('/trpc/frontend/frontend.namespaces.list?input=%7B%7D')
        ns_uuid2 = None
        if lr.ok:
            for ns in lr.json().get('result',{}).get('data',{}).get('data',[]):
                if ns.get('uuid') == ns_name_or_uuid or ns.get('name') == ns_name_or_uuid:
                    ns_uuid2 = ns.get('uuid'); break
        if not ns_uuid2: return
        tr = (transport or 'SSE').upper()
        if tr in ('SSE','STREAMABLE'): tr = 'SSE' if tr=='SSE' else 'STREAMABLE_HTTP'
        body = {'name': ep_name, 'namespaceUuid': ns_uuid2, 'transport': tr}
        if isinstance(extra, dict): body.update(extra)
        r = trpc_post('/trpc/frontend/frontend.endpoints.create', body)
        if r.ok:
            log(f"created endpoint: {ep_name} ({tr})")

    ep_name = b_endpoint.get('name') or ns_name
    if ep_name and ns_uuid:
        create_endpoint(ep_name, ns_uuid, b_endpoint.get('transport'))

    for ep in p_endpoints:
        name = ep.get('name'); nsref = ep.get('namespace') or ep.get('namespaceUuid')
        if not (name and nsref): continue
        extra = {k: ep[k] for k in ('enableApiKeyAuth','enableOauth','useQueryParamAuth') if k in ep}
        create_endpoint(name, nsref, ep.get('transport'), extra)
{{- end }}
